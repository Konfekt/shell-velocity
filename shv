#!/bin/sh

set -e
# set -x

editor="${SHV_EDITOR:=${EDITOR:=vi}}"
subcmd="${SHV_DEFAULT_CMD:=search}"
picker="${SHV_PICKER:="fzf -m --ansi --print-query --bind=alt-enter:print-query"}"
path="${SHV_PATH:=$HOME/Documents/notes}"
diary_path=${SHV_DIARY_PATH:=$SHV_PATH/diary}
date_fmt=${SHV_DATE_FMT:=%Y-%m-%d}
ignore=${SHV_IGNORE:=./.obsidian/* ./.git/*}
auto_cd=${SHV_AUTO_CD:=true}
history_on=${SHV_HISTORY:=true}
capture_file="$SHV_CAPTURE_FILE"
exts=${SHV_EXTS:=md adoc txt org}
os=$(uname)
ext=$(printf "%s" "$SHV_EXTS" | cut -d' ' -f1)
histfile="${XDG_DATA_HOME:-$HOME/.local/share}/shv_history"

###### UTILITY ######

help() {
    cat <<EOF
shell velocity an efficient note taking utility
shv [-h|--help] <action>

actions:
  bookmarks | b
  capture | c
  diary
  history | h
  search <default>
  select | sel
  today | t
  tomorrow | tm
  yesterday | y
EOF
    exit 0
}

version() {
    front=$(git rev-list --count HEAD)
    back=$(git rev-parse --short HEAD)
    printf "r%s.%s\n" "$front" "$back"
    exit 0
}

# Echo to stderr and quit
die() {
    printf '%s: %s.\n' "$0" "$1" >&2
    exit 1
}

strip() {
    # Remove all leading white-space.
    # '${1%%[![:space:]]*}': Strip everything but leading white-space.
    # '${1#${XXX}}': Remove the white-space from the start of the string.
    str="${1#"${1%%[![:space:]]*}"}"
    # Remove all trailing white-space.
    # '${trim##*[![:space:]]}': Strip everything but trailing white-space.
    # '${trim%${XXX}}': Remove the white-space from the end of the string.
    str="${str%"${str##*[![:space:]]}"}"
    printf "%s" "$str"
}

# Normalize string in an usable state
# $1: String
normalize() {
    str=$(strip "$1" | sed "s/\n/#/g; s/\ /-/g; s/\n/#/g; s/#/\s/g")
    printf "%s" "$str"
}

# Parse output of fuctions and return string of files
# $1: filenames
# $2: directory
parse() {
    args=$(normalize "$1")
    for i in $args; do
        [ -f "$i" ] \
            && file=${file:+"$file "}$i \
            || tmp="$2/$i.$ext"
    done
    [ -z "$file" ] && file=$tmp
    printf "%s" "$file"
}

# List files in dir
# $1: directory
get_files() {
    set -f
    query=""
    for ext in $exts; do
        query="${query:+${query} -o} -iname *.${ext}"
    done
    ignore=""
    for ign in $exts; do
        ignore="${ignore:+${ignore}} -not -path ${ign}"
    done
    find "$1" -type f '(' $query ')' '(' $ignore ')'
    set +f
}

# Returns the date of selected day by standard of date command
# $1: n of days
get_date() {
    if [ "$os" = "Linux" ]; then
        date=$(date -d "$1 days" +"$date_fmt")
    else
        date=$(date -v"$1"d +"$date_fmt")
    fi
    printf "%s" "$date"
}

store_hist() {
    files=$(printf "%s" "$@" | tr ' ' '\n')
    dirname=$(dirname "$histfile")
    [ -d "$dirname" ] \
        && printf "%s\n" "$files" >>"$histfile"
}

###### COMMANDS ######

# Returns path to bookmarked file
# $1: index of file in "array" (starts at 1)
bookmark() {
    [ -z "$SHV_BMS" ] && die "There are no bookmarked files"
    bmk=$(printf "%s" "$SHV_BMS" | cut -d' ' -f"$1")
    printf "%s/%s" "$path" "$bmk"
}

capture() {
    [ -z "$capture_file" ] \
        && file=$(diary_note +0) \
        || file="$capture_file"
    printf "%s\n\n" "$*" >>"$file"
}

# Returns the path to note of specified day
# $1: n days
# $2: label
diary_note() {
    date=$(get_date "$1")
    if [ -z "$2" ]; then
        printf "%s/%s.%s" "$diary_path" "$date" "$ext"
    else
        printf "%s/%s_%s.%s" "$diary_path" "$date" "$2" "$ext"
    fi
}

# Edit note with EDITOR
# $*: Path to file to edit
edit_notes() {
    "$history_on" \
        && store_hist "$@"
    $editor $*
}

restore_hist() {
    if ! "$history_on"; then
        die "history is not enabled"
    elif ! [ -r "$histfile" ]; then
        die "$histfile is not a redable"
    else
        file=$(sort -u "$histfile" | sed "/^$/ d" | $picker)
        printf "%s" "$file"
    fi
}

# Handler to search/create notes
search_notes() {
    sel=$(get_files "$path" | xargs grep -H "" | $picker | sed "s/:.*//g")
    [ -z "$sel" ] && exit 1
    file=$(parse "$sel" "$path")
    printf "%s" "$file"
}

# Handler to select/create notes
# $1: directory to search
select_notes() {
    sel=$(get_files "$1" | $picker | sed "s/\n/#/g")
    [ -z "$sel" ] && exit 1
    file=$(parse "$sel" "$1")
    printf "%s" "$file"
}

###### MAIN ######

# Main function
# $1: subcommands
main() {
    [ -d "$path" ] || die "SHV_PATH doesn't exist"
    "$auto_cd" && cd "$path"
    case "${1:-$subcmd}" in
        bookmarks | b)
            note=$(bookmark "$2")
            ;;
        capture | c)
            args="$*"
            capture "${args##"$1" }"
            ;;
        diary)
            note=$(select_notes "$diary_path")
            ;;
        history | h)
            note=$(restore_hist)
            ;;
        search)
            note=$(search_notes)
            ;;
        select | sel)
            note=$(select_notes "$path")
            ;;
        today | t)
            note=$(diary_note +0 "$2")
            ;;
        tomorrow | tm)
            note=$(diary_note +1 "$2")
            ;;
        yesterday | y)
            note=$(diary_note -1 "$2")
            ;;
        -h | --help)
            help
            ;;
        -v | --version)
            version
            ;;
        *)
            die "\"$1\" unrecognized option"
            help
            ;;
    esac
    [ -z "$note" ] && exit 0
    edit_notes "$note"
}

if [ -p /dev/stdin ]; then
    capture "$(cat -)"
else
    main "$@"
fi
