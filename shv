#!/bin/sh

set -e
# set -x

: "${SHV_EDITOR:=${EDITOR:=vi}}"
: "${SHV_DEFAULT_CMD:=search}"
: "${SHV_PICKER:="fzf -m --ansi --print-query --bind=alt-enter:print-query"}"
: "${SHV_PATH:=$HOME/Documents/notes}"
: "${SHV_DIARY_PATH:=$SHV_PATH/diary}"
: "${SHV_EXTS:=md adoc txt org}"
: "${SHV_DATE_FMT:=%Y-%m-%d}"
: "${SHV_IGNORE:=./.obsidian/* ./.git/*}"
: "${SHV_AUTO_CD:=true}"
: "${SHV_HISTORY:=true}"
: "${SHV_CAPTURE_FILE:=}"
: "${SHV_BMS}"

os=$(uname)
ext=$(printf "%s" "$SHV_EXTS" | cut -d' ' -f1)
histfile="${XDG_DATA_HOME:-$HOME/.local/share}/shv_history"

###### UTILITY ######

help() {
# tag::help[]
    cat <<EOF
shell velocity an efficient note taking utility
shv [-h|--help] <action>

actions:
  bookmarks | b
  capture | c
  diary
  history | h
  search <default>
  select | sel
  today | t
  tomorrow | tm
  yesterday | y
EOF
# end::help[]
    exit 0
}

version() {
    front="$(git rev-list --count HEAD)"
    back="$(git rev-parse --short HEAD)"
    printf "r%s.%s\n" "$front" "$back"
    exit 0
}

# Echo to stderr and quit
die() {
    printf '%s: %s.\n' "$0" "$1" >&2
    exit 1
}

strip() {
    # Remove all leading white-space.
    # '${1%%[![:space:]]*}': Strip everything but leading white-space.
    # '${1#${XXX}}': Remove the white-space from the start of the string.
    str="${1#"${1%%[![:space:]]*}"}"
    # Remove all trailing white-space.
    # '${trim##*[![:space:]]}': Strip everything but trailing white-space.
    # '${trim%${XXX}}': Remove the white-space from the end of the string.
    str="${str%"${str##*[![:space:]]}"}"
    printf "%s" "$str"
}

# Normalize string in an usable state
# $1: String
normalize() {
    str=$(strip "$1" | sed "s/\n/#/g; s/\ /-/g; s/\n/#/g; s/#/\s/g")
    printf "%s" "$str"
}

# Parse output of fuctions and return string of files
# $1: filenames
# $2: directory
parse() {
    args=$(normalize "$1")
    for i in $args; do
        [ -f "$i" ] \
            && file=${file:+"$file "}$i \
            || tmp="$2/$i.$ext"
    done
    [ -z "$file" ] && file=$tmp
    printf "%s" "$file"
}

# List files in dir
# $1: directory
get_files() {
    set -f
    query=""
    for ext in $SHV_EXTS; do
        query="${query:+${query} -o} -iname *.${ext}"
    done
    ignore=""
    for ign in $SHV_IGNORE; do
        ignore="${ignore:+${ignore}} -not -path ${ign}"
    done
    find "$1" -type f '(' $query ')' '(' $ignore ')'
    set +f
}

# Returns the date of selected day by standard of date command
# $1: n of days
get_date() {
    if [ "$os" = "Linux" ]; then
        date="$(date -d "$1 days" +"$SHV_DATE_FMT")"
    else
        date="$(date -v"$1"d +"$SHV_DATE_FMT")"
    fi
    printf "%s" "$date"
}

store_hist() {
    files=$(printf "%s" "$@" | tr ' ' '\n')
    dirname=$(dirname "$histfile")
    [ -d "$dirname" ] \
        && printf "%s\n" "$files" >>"$histfile"
}

###### COMMANDS ######

# Returns path to bookmarked file
# $1: index of file in "array" (starts at 1)
bookmark() {
    [ -z "$SHV_BMS" ] && die "There are no bookmarked files"
    bmk=$(printf "%s" "$SHV_BMS" | cut -d' ' -f"$1")
    printf "%s/%s" "$SHV_PATH" "$bmk"
}

capture() {
    [ -z "$SHV_CAPTURE_FILE" ] \
        && file="$(diary_note +0)" \
        || file="$SHV_CAPTURE_FILE"
    printf "%s\n\n" "$*" >>"$file"
}

# Returns the path to note of specified day
# $1: n days
# $2: label
diary_note() {
    date=$(get_date "$1")
    if [ -z "$2" ]; then
        printf "%s/%s.%s" "$SHV_DIARY_PATH" "$date" "$ext"
    else
        printf "%s/%s_%s.%s" "$SHV_DIARY_PATH" "$date" "$2" "$ext"
    fi
}

# Edit note with EDITOR
# $*: Path to file to edit
edit_notes() {
    [ "$SHV_HISTORY" = true ] \
        && store_hist "$@"
    $SHV_EDITOR $*
}

restore_hist() {
    if [ "$SHV_HISTORY" = false ]; then
        die "history is not enabled"
    elif ! [ -r "$histfile" ]; then
        die "$histfile is not a redable"
    else
        file=$(sort -u "$histfile" | sed "/^$/ d" | $SHV_PICKER)
        printf "%s" "$file"
    fi
}

# Handler to search/create notes
search_notes() {
    sel=$(get_files "$SHV_PATH" | xargs -I {} grep -H "" {} | $SHV_PICKER | sed "s/:.*//g")
    [ -z "$sel" ] && exit 1
    file=$(parse "$sel" "$SHV_PATH")
    printf "%s" "$file"
}

# Handler to select/create notes
# $1: directory to search
select_notes() {
    sel=$(get_files "$1" | $SHV_PICKER | tr '\n' '#')
    [ -z "$sel" ] && exit 1
    file=$(parse "$sel" "$1")
    printf "%s" "$file"
}

###### MAIN ######

# Main function
# $1: subcommands
main() {
    sub=$1
    sub=${sub:=$SHV_DEFAULT_CMD}
    [ "$SHV_AUTO_CD" = true ] && cd "$SHV_PATH"
    [ -d "$SHV_PATH" ] || die "SHV_PATH doesn't exist"
    case "$sub" in
        bookmarks | b)
            note=$(bookmark "$2")
            ;;
        capture | c)
            args="$*"
            capture "${args##"$1" }"
            ;;
        diary)
            note=$(select_notes "$SHV_DIARY_PATH")
            ;;
        history | h)
            note=$(restore_hist)
            ;;
        search)
            note=$(search_notes)
            ;;
        select | sel)
            note=$(select_notes "$SHV_PATH")
            ;;
        today | t)
            note=$(diary_note +0 "$2")
            ;;
        tomorrow | tm)
            note=$(diary_note +1 "$2")
            ;;
        yesterday | y)
            note=$(diary_note -1 "$2")
            ;;
        -h | --help)
            help
            ;;
        -v | --version)
            version
            ;;
        *)
            die "\"$1\" unrecognized option"
            help
            ;;
    esac
    [ -z "$note" ] && exit 0
    edit_notes "$note"
}

if [ -p /dev/stdin ]; then
    capture "$(cat -)"
else
    main "$@"
fi
